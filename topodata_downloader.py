# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TopodataDownloader
                                 A QGIS plugin
 Baixa automaticamente MDEs do Topodata com base em poligono
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-31
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Markus Scheid Anater
        email                : markus.scheid.anater@gmail.com
 ***************************************************************************/

/***************************************************************************
 * *
 * This program is free software; you can redistribute it and/or modify  *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation; either version 2 of the License, or     *
 * (at your option) any later version.                                   *
 * *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QThread
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox, QCheckBox, QSizePolicy, QDialog, QDesktopWidget
from qgis.core import QgsProject, QgsVectorLayer, QgsMessageLog, Qgis, QgsApplication
from qgis.gui import QgsMessageBar

from .resources import *
from .topodata_downloader_dialog import TopodataDownloaderDialog
from .spatial_analysis import *
from .download_raster_worker import DownloadWorker
from .unzip_worker import UnzipWorker
import os.path
import os

class TopodataDownloader:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        
        # Salva a referência para a interface QGIS
        self.iface = iface
        # Inicializa o diretório do plugin
        self.plugin_dir = os.path.dirname(__file__)
        # Inicializa a tradução (se aplicável)
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'TopodataDownloader_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declara atributos de instância
        self.actions = []
        self.menu = self.tr(u'&Topodata Dowloader')
        self.first_start = None
        self.dlg = None
        self.download_thread = None
        self.download_worker = None
        self.unzip_thread = None
        self.unzip_worker = None
        self.total_urls = 0
        self.completed_downloads = 0

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('TopodataDownloader', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        
      
        icon = QIcon(icon_path)

        icon_path = os.path.join(os.path.dirname(__file__), "icon.png")
        print("Caminho do ícone:", icon_path, os.path.exists(icon_path))

        icon = QIcon(icon_path)
        print("Ícone é nulo?", icon.isNull())

        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adiciona o ícone do plugin à barra de ferramentas de Plugins
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        icon_path = ':/plugins/topodata_downloader/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Topodata Downloader'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # será definido como False em run()
        self.first_start = True

    def unload(self):
        """Remove o item do menu do plugin e o ícone da GUI do QGIS."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Topodata Dowloader'),
                action)
            self.iface.removeToolBarIcon(action)
        

    def run(self):
        """
        Executa o plugin, criando e exibindo o diálogo.
        Conecta os sinais da nova interface.
        """
        #if self.first_start:
        self.first_start = False
        self.dlg = TopodataDownloaderDialog(self.iface.mainWindow())
        self.dlg.pushButton_close.setIcon(QIcon(QgsApplication.iconPath("mActionStop.svg"))) 
        self.dlg.pushButton_start.setIcon(QIcon(QgsApplication.iconPath("mActionPlay.svg")))

        self.center_dialog(self.dlg)
        
        # Conecta os botões da nova interface às funções
        self.dlg.pushButton_selectFile.clicked.connect(self.select_input_file)
        self.dlg.pushButton_start.clicked.connect(self.start_process)
        self.dlg.pushButton_close.clicked.connect(self.on_close_clicked)

        self.message_bar = QgsMessageBar()
        self.message_bar.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        self.dlg.layout().insertWidget(0, self.message_bar)  # insere no topo da janela
        
        self.dlg.show()

    def center_dialog(self, dialog):
        """Centraliza o diálogo na janela principal do QGIS"""
        # Obtém a janela principal do QGIS
        main_window = self.iface.mainWindow()
        
        # Calcula a geometria da janela principal
        main_rect = main_window.frameGeometry()
        
        # Calcula a geometria do diálogo
        dialog_rect = dialog.frameGeometry()
        
        # Move o diálogo para o centro da janela principal
        dialog.move(
            main_rect.center() - dialog_rect.center()
        )
    
    def select_input_file(self):
        """
        Abre um seletor de arquivo e carrega a camada se um arquivo for escolhido.
        """
        file_path, _ = QFileDialog.getOpenFileName(
            self.dlg,
            "Selecionar Arquivo Vetorial",
            "",
            "Shapefiles (*.shp);;GeoPackages (*.gpkg);;Todos os arquivos (*)"
        )

        if file_path:
            # Carrega o arquivo como uma nova camada no QGIS
            layer_name = os.path.basename(file_path).split('.')[0]
            new_layer = QgsVectorLayer(file_path, layer_name, "ogr")
            
            if new_layer.isValid():
                QgsProject.instance().addMapLayer(new_layer)
                # Define a nova camada como o item selecionado no ComboBox
                self.dlg.mMapLayerComboBox.setLayer(new_layer)
                self.message_bar.pushMessage(
                    "Sucesso",
                    f"Camada '{new_layer.name()}' carregada.",
                    level=Qgis.Success
                )
            else:
                self.message_bar.pushMessage(
                    "Erro",
                    "Falha ao carregar o arquivo.",
                    level=Qgis.Critical
                )

    def start_process(self):
        """
        Inicia o processo completo de download e descompactação.
        """
        # 1. Valida a camada de entrada
        input_layer = self.dlg.mMapLayerComboBox.currentLayer()
        if not input_layer or not input_layer.isValid():
            self.message_bar.pushMessage("Erro", "Por favor, selecione uma camada de polígono válida.", level=Qgis.Critical)
            return

        # 2. Valida a pasta de destino
        dest_path = self.dlg.mFileWidget.filePath()
        if not dest_path:
            self.message_bar.pushMessage(
                    "Erro",
                    "Por favor, selecione uma pasta de destino.",
                    level=Qgis.Warning,
                    duration=5
                )
            return
        
        # 3. Obtém os sufixos selecionados
        selected_suffixes = []
        for checkbox in self.dlg.groupBox_options.findChildren(QCheckBox):
            if checkbox.isChecked():
                suffix = checkbox.property("suffix")
                if suffix:  # garante que a propriedade existe
                    selected_suffixes.append(suffix)

        if not selected_suffixes:
            self.message_bar.pushMessage(
                    "Erro",
                    "Por favor, selecione pelo menos um arquivo para baixar.",
                    level=Qgis.Warning,
                    duration=5
                )
            return

        # 4. Checa se o poligono é valido
        if not is_valid_polygon(input_layer.source()):
            self.message_bar.pushMessage(
                    "Erro",
                    "O poligono selecionado é invalido!",
                    level=Qgis.Warning,
                    duration=5
                )
            return

        # 5. Checa se o poligono selecionado está contido na grid
        grid_path = self.get_grade_path()
        if not is_polygon_within_grid(input_layer.source(), grid_path):
            self.message_bar.pushMessage(
                    "Erro",
                    "O poligono selecionado está fora da area de abrangencia.",
                    level=Qgis.Warning,
                    duration=5
                )
            return

        # 6. Inicia o processamento
        self._log_message("Iniciando processo...")
        self._log_message(f'Sufixo dos arquivos: {selected_suffixes}')
        self.dlg.pushButton_start.setEnabled(False) # Desabilita o botão para evitar cliques múltiplos
        self.dlg.progressBar.setValue(0)
        self.completed_downloads = 0
        
        
        # A lógica para obter os códigos únicos de quadrantes
        unique_tile_codes = analyze_polygon_against_grid(input_layer.source(), grid_path)
        if not unique_tile_codes:
            self.message_bar.pushMessage(
                    "Erro",
                    "Não foram encontrados quadrantes para o poligono selecionado.",
                    level=Qgis.Warning,
                    duration=5
                )
            return

        self._log_message(f'Quadrantes: {unique_tile_codes}')

        quadrants_path = self.get_quadrants_path()
        quadrant_dict = create_quadrant_dict(read_csv_file(quadrants_path))

        quadrant_dict_filtered = filter_quadrant_by_suffix(selected_suffixes, unique_tile_codes, quadrant_dict)

        urls_to_download = load_url_quadrants(quadrant_dict_filtered)
        self.total_urls = len(urls_to_download)
        
        for url in urls_to_download:
            self._log_message(url)

        self.call_download_worker(urls_to_download, dest_path)
    
    def on_close_clicked(self):
         # Cancela download em andamento
        if self.download_worker:
            self.download_worker.cancel()
        
        self.finalize_process()
        self.dlg.close()

    def _log_message(self, message, level=Qgis.Info):
        """
        Helper para adicionar mensagens no log da interface.
        """
        self.dlg.textEdit_log.append(f"[Log] {message}")
        QgsMessageLog.logMessage(message, "Topodata Downloader", level=level)

    def call_download_worker(self, urls_to_download, dest_path):
        """
        Inicializa e executa o DownloadWorker em uma QThread.
        """
        self.download_thread = QThread()
        
        self.download_worker = DownloadWorker(urls_to_download, dest_path)
        self.download_worker.moveToThread(self.download_thread)

        # Conexões de sinais atualizadas
        self.download_worker.started.connect(self._log_message)
        self.download_worker.file_started.connect(self.on_download_file_started)
        self.download_worker.download_progress.connect(self.on_download_progress_file)
        self.download_worker.file_finished.connect(self.on_download_file_finished)
        self.download_worker.finished.connect(self.on_download_finished)
        self.download_worker.error.connect(self.on_download_error)
        
        self.download_thread.started.connect(self.download_worker.start)
        
        # Conecta a thread para ser encerrada e limpa
        self.download_worker.finished.connect(self.download_thread.quit)
        self.download_worker.finished.connect(self.download_worker.deleteLater)
        self.download_thread.finished.connect(self.download_thread.deleteLater)

        self.download_thread.start()

    def on_download_file_started(self, filename, index):
        """
        Slot chamado quando um novo arquivo começa a ser baixado.
        """
        self._log_message(f"Baixando arquivo {index + 1}/{self.total_urls}: {filename}")
        # A barra de progresso será atualizada continuamente pelo sinal de progresso do arquivo

    def on_download_progress_file(self, bytes_received, bytes_total):
        """
        Atualiza a barra de progresso com o progresso do arquivo atual.
        """
        if bytes_total > 0 and self.total_urls > 0:
            # Calcula a base do progresso com base nos arquivos já concluídos
            base_progress = (self.completed_downloads / self.total_urls) * 100
            # Calcula o progresso do arquivo atual em relação ao total
            current_file_progress = (bytes_received / bytes_total) * (100 / self.total_urls)
            
            total_progress = int(base_progress + current_file_progress)
            self.dlg.progressBar.setValue(total_progress)
            
    def on_download_file_finished(self):
        """
        Slot chamado quando um download de arquivo é concluído (com ou sem erro).
        Incrementa a contagem de downloads concluídos.
        """
        self.completed_downloads += 1
        self._log_message(f"Download do arquivo concluído. Total: {self.completed_downloads}/{self.total_urls}")


    def on_download_finished(self, dest_path, zip_files_downloaded):
        """Callback após o DownloadWorker finalizar."""
        self._log_message(f"Download completo. Arquivos salvos em: {dest_path}")
        self.completed_downloads = 0
        self.call_unzip_worker(dest_path, zip_files_downloaded)

    def on_download_error(self, msg):
        """Callback para erros no DownloadWorker."""
        self._log_message(f"Erro no download: {msg}", level=Qgis.Critical)
        self.dlg.pushButton_start.setEnabled(True)
        # Garante que a barra de progresso seja redefinida para 0 em caso de erro
        self.dlg.progressBar.setValue(0)
        self.completed_downloads = 0


    def call_unzip_worker(self, dest_path, zip_files_downloaded):
        """
        Inicializa e executa o UnzipWorker em uma QThread.
        """
        self.unzip_thread = QThread()
        self.unzip_worker = UnzipWorker(dest_path, zip_files_downloaded)
        self.unzip_worker.moveToThread(self.unzip_thread)

        self.unzip_worker.started.connect(self._log_message)
        self.unzip_worker.progress.connect(self.on_unzip_progress)
        self.unzip_worker.finished.connect(self.on_unzip_finished)
        self.unzip_worker.error.connect(self.on_unzip_error)
        self.unzip_thread.started.connect(self.unzip_worker.start)

        # Conecta a thread para ser encerrada e limpa
        self.unzip_worker.finished.connect(self.unzip_thread.quit)
        self.unzip_worker.finished.connect(self.unzip_worker.deleteLater)
        self.unzip_thread.finished.connect(self.unzip_thread.deleteLater)

        self.unzip_thread.start()
        
    def on_unzip_progress(self, current, total):
        """Atualiza a barra de progresso com o progresso da descompactação."""
        if total > 0:
            percentage = (current / total) * 100
            self.dlg.progressBar.setValue(int(percentage))

    def on_unzip_finished(self, unzip_files):
        """Callback após o UnzipWorker finalizar."""
        self._log_message(f"Descompactação completa!")
        self.dlg.pushButton_start.setEnabled(True)
        # Código para adicionar as camadas ao QGIS
        add_layers(unzip_files)

        results = add_layers(unzip_files)

        # Gera o log no arquivo principal a cada iteração
        for tif_path, status in results:
            if status:
                self._log_message(f"Camada '{os.path.basename(tif_path)}' adicionada.")
            else:
                self._log_message(f"A camada '{tif_path}' é inválida e não foi adicionada.")

        self.finalize_process()

    def on_unzip_error(self, msg):
        """Callback para erros no UnzipWorker."""
        self._log_message(f"Erro ao descompactar: {msg}", level=Qgis.Critical)
        self.dlg.progressBar.setValue(0)
        self.dlg.pushButton_start.setEnabled(True)
        self.finalize_process()

    def finalize_process(self):
        self.message_bar.pushMessage(
            "Sucesso",
            "Plugin executado com sucesso!",
            level=Qgis.Success,
            duration=5
        )
        self._log_message("Processo finalizado")
    

    def get_grade_path(self):
        plugin_dir = os.path.dirname(__file__)
        grid_path = os.path.join(plugin_dir, 'resources', 'brazil_grid.geojson')
        return grid_path
    
    def get_quadrants_path(self):
        plugin_dir = os.path.dirname(__file__)
        quadrants_path = os.path.join(plugin_dir, 'resources', 'quadrants.csv')
        return quadrants_path

    